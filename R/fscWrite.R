#' @title Run fastsimcoal
#' @description Run a fastsimcoal simulation and load results into a 
#'   \linkS4class{gtypes} object.
#'
#' @param demes matrix of deme sampling information created by the 
#'   \code{\link{fscSettingsDemes}} function.
#' @param genetics data.frame specifying loci to simulate created by the 
#'   \code{\link{fscSettingsGenetics}} function.
#' @param migration a list of matrices giving the migration rates 
#'   between pairs of demes created by the \code{\link{fscSettingsMigration}} 
#'   function.
#' @param events matrix of historical events created by the 
#'   \code{\link{fscSettingsEvents}} function.
#' @param label character string to label files with.
#' 
#' @note fastsimcoal is not included with `strataG` and must be downloaded 
#'   separately. Additionally, it must be installed such that it can be run from 
#'   the command line in the current working directory. See the vignette 
#'   for \code{external.programs} for installation instructions.
#' 
#' @references Excoffier, L. and Foll, M (2011) fastsimcoal: a continuous-time 
#'   coalescent simulator of genomic diversity under arbitrarily complex 
#'   evolutionary scenarios Bioinformatics 27: 1332-1334.\cr
#'   Excoffier, L., Dupanloup, I., Huerta-SÃ¡nchez, E., Sousa, V.C., 
#'   and M. Foll (2013) Robust demographic inference from genomic and SNP data. 
#'   PLOS Genetics, 9(10):e1003905. \cr
#'   \url{http://cmpg.unibe.ch/software/fastsimcoal2/}
#' 
#' @author Eric Archer \email{eric.archer@@noaa.gov}
#' 
#' @seealso \code{\link{fsc.input}}
#' 
#' @name fscWrite
#' @export
#' 
fscWrite <- function(demes, genetics, migration = NULL, events = NULL, 
                     label = "strataG.fastsimcoal") {
  opt <- options(scipen = 999)
  p <- list(
    label = make.names(label),
    files = list(),
    settings = list(
      demes = demes,
      migration = migration, 
      events = events,
      genetics = genetics
    )
  )
  .fscCheckInput(p)
  p <- .fscWritePar(p) 
  if(p$is.tpl) p <- .fscWriteEst(p)
  p$formatted.settings <- NULL
  options(opt)
  
  invisible(p)
}


#' @noRd
#' 
.fscCheckInput <- function(p) {
  ps <- p$settings
  
  # Check deme info
  if(!inherits(ps$demes, "fscSettingsDemes")) {
    stop("`demes` must be a numeric matrix generated by the `fscSettingsDemes()` function.")
  }
  
  # Check migration rate matrices
  if(!is.null(ps$migration)) {
    if(!inherits(ps$migration, "fscSettingsMigration")) {
      stop("`migration` must be a list of matrices generated by `fscSettingsMigration()`.")
    }
    if(!all(sapply(ps$migration, nrow) == nrow(ps$demes))) {
      stop("All matrices in `migration` must be the same size as the number of demes")
    }
  }
  
  # Check and format historical events
  if(!is.null(ps$events)) {
    if(!inherits(ps$events, "fscSettingsEvents")) {
      stop("`events` must be a numeric matrix generated by `fscSettingsEvents()`.")
    }
    if(any(ps$events[, 2:3] > (nrow(ps$demes) - 1))) {
      stop("There are source or sink populations in `events` not specified in `demes`.")
    }
    max.mig.mat <- max(ps$events[, 7])
    if(max.mig.mat > 0 & (length(ps$migration) < (max.mig.mat + 1))) {
      stop("There are migration matrices in `events` not specified in `migration`.")
    }
  }
  
  # Check genetic info
  if(!inherits(ps$genetics, "fscSettingsGenetics")) {
    stop("`genetics` must be a list of matrices generated by `fscSettingsGenetics()`.")
  }
  if(any(ps$genetics$fsc.type == "FREQ") & attr(ps$demes, "ploidy") != 1) {
    warning("With FREQ type, `ploidy` is set to 1.")
    attr(ps$demes, "ploidy") <- 1
  }
}


#' @noRd
#' 
.fscWritePar <- function(p) {
  p <- .fscFormatSettings(p)
  
  p$files$in.file <- paste0(p$label, ifelse(p$is.tpl, ".tpl", ".par"))
  f <- file(p$files$in.file, open = "wt")
  
  pfs <- p$formatted.settings
  
  n.demes <- nrow(pfs$demes)
  writeLines("//Number of population samples (demes)", f)
  writeLines(as.character(n.demes), f)
  
  writeLines("//Population effective sizes (number of genes)", f)
  for(i in 1:n.demes) writeLines(pfs$demes[i, 1], f)
  
  writeLines("//Sample sizes, times, inbreeding", f)
  for(i in 1:n.demes) writeLines(paste(pfs$demes[i, 2:4], collapse = " "), f)
  
  writeLines("//Growth rates: negative growth implies population expansion", f)
  for(i in 1:n.demes) writeLines(pfs$demes[i, 5], f)
  
  writeLines("//Number of migration matrices: 0 implies no migration between demes", f)
  writeLines(as.character(length(pfs$migration)), f)
  if(!is.null(pfs$migration)) {
    for(i in 1:length(pfs$migration)) {
      writeLines("//migration matrix", f)
      for(r in 1:nrow(pfs$migration[[i]])) {
        writeLines(paste(pfs$migration[[i]][r, ], collapse = " "), f)
      }
    }
  }
  
  writeLines("//Historical events: time, source, sink, migrants, new size, growth rate, migr. matrix", f)
  n.events <- if(is.null(pfs$events)) 0 else nrow(pfs$events)
  writeLines(as.character(n.events), f)
  if(!is.null(pfs$events)) {
    for(r in 1:n.events) writeLines(paste(pfs$events[r, ], collapse = " "), f)
  }
  
  writeLines("//Number of independent loci [chromosomes]", f)
  num.chrom <- attributes(pfs$genetics)["num.chrom"]
  chrom.diff <- as.numeric(attributes(pfs$genetics)["chrom.diff"])
  writeLines(paste(num.chrom, chrom.diff, collapse = " "), f)
  for(block in pfs$genetics) {
    writeLines("//Per chromosome: Number of linkage blocks", f)
    writeLines(as.character(nrow(block)), f)
    writeLines("//Per block: data type, num loci, rec. rate and mut rate + optional parameters", f)
    for(i in 1:nrow(block)) {
      writeLines(paste(as.character(block[i, -1]), collapse = " "), f)
    }
  }
  
  close(f)
  p
}


#' @noRd
#' 
.fscFormatSettings <- function(p) {
  .mat2char <- function(mat) {
    matrix(
      as.character(mat),
      nrow = nrow(mat),
      dimnames = dimnames(mat)
    )
  }
  
  .nameParams <- function(mat) {
    # convert NAs to parameters if any exist 
    for(col in colnames(mat)) {
      i <- which(is.na(mat[, col]))
      if(length(i) > 0) mat[i, col] <- toupper(paste0(col, 1:length(i), "$"))
    }
    mat
  }
  
  p$formatted.settings <- list()
  
  # have to increase population size by ploidy as fastsimcoal generates 
  #   haploid number of genes
  ploidy <- attr(p$settings$demes, "ploidy")
  demes <- p$settings$demes
  demes[, 1:2] <- demes[, 1:2] * ploidy
  p$formatted.settings$demes <- .nameParams(.mat2char(demes))
  
  p$formatted.settings$migration <- if(is.null(p$settings$migration)) {
    NULL
  } else {
    lapply(
      1:length(p$settings$migration), 
      function(m) {
        mat <- .mat2char(p$settings$migration[[m]] / ploidy)
        # convert NAs to parameters 
        for(i in 1:nrow(mat)) {
          for(j in 1:ncol(mat)) {
            if(is.na(mat[i, j])) {
              mat[i, j] <- paste0("MIG", m - 1, "_", i, "_", j, "$", collapse = 0)
            }
          }
        }
        mat
      })
  }
  
  p$formatted.settings$events <- if(is.null(p$settings$events)) {
    NULL
  } else {
    .nameParams(.mat2char(p$settings$events))
  }
  
  p$formatted.settings$genetics <- p$settings$genetics
  for(chrom in 1:length(p$formatted.settings$genetics)) {
    chr.df <- p$formatted.settings$genetics[[chrom]]
    for(col in colnames(chr.df)) {
      i <- which(is.na(chr.df[, col]))
      if(length(i) > 0) {
        if((col == "num.markers")) stop("Can't estimate number of markers.")
        marker.type <- chr.df[i, "fsc.type"]
        chr.df[i, col] <- ifelse(
          (col == "param.5" & marker.type == "STANDARD") |
          (col == "param.6" & marker.type %in% c("DNA", "STANDARD")),
          rep("", length(i)),
          toupper(paste0(marker.type , "_", col, "_", 1:length(i), "$"))
        )
      }
    }
    p$formatted.settings$genetics[[chrom]] <- chr.df
  }
  
  # Check for parameters to be estimated
  p$is.tpl <- any(
    c(
      grepl("[$]", p$formatted.settings$demes),
      grepl("[$]", p$formatted.settings$migration),
      grepl("[$]", p$formatted.settings$events),
      grepl("[$]", p$formatted.settings$genetics)
    )
  )

  p
}


#' @noRd
#' 
.fscWriteEst <- function(p) {
  p$files$est.file <- paste0(p$label, ".est")
  
  if(file.exists(p$files$est.file) & interactive()) {
    prompt <- paste0(
      "The estimation file, '", 
      p$files$est.file, 
      "' already exists. Overwrite? (Y/n) "
    )
    if(readline(prompt) != "Y") return(p)
  }
  
  f <- file(p$files$est.file, open = "wt")
  
  pfs <- p$formatted.settings
  
  est.df <- data.frame()
  for(col in colnames(pfs$demes)) {
    param <- grep("[$]", pfs$demes[, col], value = T)
    if(length(param) > 0) {
      is.int <- col %in% c("deme.size", "sample.size", "sample.time")
      est.df <- rbind(est.df, data.frame(int = as.numeric(is.int), param))
    }
  }
  
  if(!is.null(p$events)) {
    for(col in colnames(pfs$events)) {
      param <- grep("[$]", pfs$events[, col], value = T)
      if(length(param) > 0) {
        is.int <- col %in% c("event.time", "source", "sink", "migr.mat")
        est.df <- rbind(est.df, data.frame(int = as.numeric(is.int), param))
      }
    }
  }
  
  if(!is.null(pfs$migration)) {
    for(mat in pfs$migration) {
      param <- grep("[$]", mat, value = T)
      if(length(param) > 0) est.df <- rbind(est.df, data.frame(int = 0, param))
    }
  }  
  
  for(chrom in pfs$genetics) {
    for(col in colnames(chrom)) {
      param <- grep("[$]", chrom[, col], value = T)
      if(length(param) > 0) {
        is.int <- col == "param.6"
        est.df <- rbind(est.df, data.frame(int = as.numeric(is.int), param))
      }
    }
  }
  
  colnames(est.df) <- c("int", "param")
  est.df$param <- as.character(est.df$param)
  
  writeLines("// Priors and rules file", f)
  writeLines("// *********************", f)
  writeLines("", f)
  writeLines("[PARAMETERS]", f)
  writeLines("//#isInt? #name #dist. #min #max", f)
  writeLines("//all N are in number of haploid individuals", f)
  for(i in 1:nrow(est.df)) {
    writeLines(
      paste0(
        paste(est.df[i, ], collapse = "\t"),
        "\tunif\tmin\tmax\toutput", 
        collapse = ""
      ), 
      f
    )
  }
  writeLines("", f)
  writeLines("[RULES]", f)
  writeLines("", f)
  writeLines("[COMPLEX PARAMETERS]", f)
  for(i in 1:nrow(est.df)) {
    writeLines(
      paste0(paste(est.df[i, ], collapse = "\t"), " = ", collapse = ""), 
      f
    )
  }
  
  close(f)
  
  message(
    "The estimation file, '", 
    p$files$est.file, 
    "', has been written and must be edited prior to running."
  )
  
  invisible(p)
}


#' #' @rdname fscWrite
#' #' @export
#' #' 
#' fscWriteSFS <- function(g, ref.allele = NULL, joint = FALSE, strata = NULL, 
#'                         na.action = c("fail", "filter", "resample"),
#'                         label = NULL) {
#'   sfs <- sfs(g, ref.allele, joint, strata, simplify = FALSE, na.action = na.action)
#'   if(is.null(label)) label <- getDescription(g)
#'   label <- make.names(label)
#'   fname <- if(!joint) {
#'     file <- paste0(
#'       label, 
#'       "_", 
#'       ifelse(is.null(ref.allele), "MAF", "DAF"), 
#'       "pop0.obs",
#'       collapse = ""
#'     )
#'     write(" 1 observations", file)
#'     write(paste0("d0_", names(sfs), collapse = "\t"), file, append = T)
#'     write(paste0(sfs, collapse = "\t"), file, append = T)
#'     file
#'   } else {
#'     pws <- combn(0:(getNumStrata(g) - 1), 2)
#'     sapply(1:length(sfs), function(p) {
#'       mat <- t(sfs[[p]])
#'       rownames(mat) <- paste0("d", pws[2, p], "_", rownames(mat))
#'       colnames(mat) <- paste0("d", pws[1, p], "_", colnames(mat))
#'       file <- paste0(
#'         label, 
#'         "_joint", 
#'         ifelse(is.null(ref.allele), "MAF", "DAF"), 
#'         "pop", pws[2, p], "_", pws[1, p],
#'         ".obs", 
#'         collapse = ""
#'       )
#'       write(" 1 observations", file)
#'       write(paste0(colnames(mat), collapse = "\t"), file, append = T)
#'       for(i in 1:nrow(mat)) {
#'         row.i <- paste0(mat[i, ], collapse = "\t")
#'         write(
#'           paste(rownames(mat)[i], row.i, collapse = "\t"), 
#'           file, append = TRUE
#'         )
#'       }
#'       file
#'     })
#'   }
#'   invisible(fname)
#' }