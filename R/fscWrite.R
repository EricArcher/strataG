#' @title Run fastsimcoal
#' @description Run a fastsimcoal simulation and load results into a 
#'   \linkS4class{gtypes} object.
#'
#' @param demes matrix of deme sampling information created by the 
#'   \code{\link{fscSettingsDemes}} function.
#' @param genetics data.frame specifying loci to simulate created by the 
#'   \code{\link{fscSettingsGenetics}} function.
#' @param migration a list of matrices giving the migration rates 
#'   between pairs of demes created by the \code{\link{fscSettingsMigration}} 
#'   function.
#' @param events matrix of historical events created by the 
#'   \code{\link{fscSettingsEvents}} function.
#' @param label character string to label files with.
#' @param x a vector containing the 1D site frequency spectrum (SFS) or 
#'   list containing one or more 2D joint SFS.
#' @param type type of SFS being written: `MAF` = folded, `DAF` = unfolded.
#' 
#' @note fastsimcoal is not included with `strataG` and must be downloaded 
#'   separately. Additionally, it must be installed such that it can be run from 
#'   the command line in the current working directory. See the vignette 
#'   for \code{external.programs} for installation instructions.
#' 
#' @references Excoffier, L. and Foll, M (2011) fastsimcoal: a continuous-time 
#'   coalescent simulator of genomic diversity under arbitrarily complex 
#'   evolutionary scenarios Bioinformatics 27: 1332-1334.\cr
#'   Excoffier, L., Dupanloup, I., Huerta-SÃ¡nchez, E., Sousa, V.C., 
#'   and M. Foll (2013) Robust demographic inference from genomic and SNP data. 
#'   PLOS Genetics, 9(10):e1003905. \cr
#'   \url{http://cmpg.unibe.ch/software/fastsimcoal2/}
#' 
#' @author Eric Archer \email{eric.archer@@noaa.gov}
#' 
#' @seealso \code{\link{fsc.input}}
#' 
#' @name fscWrite
#' @export
#' 
fscWrite <- function(demes, genetics, migration = NULL, events = NULL, 
                     label = "strataG.fastsimcoal") {
  p <- list(
    label = make.names(label),
    files = list(),
    settings = list(
      demes = demes,
      migration = migration, 
      events = events,
      genetics = genetics
    )
  )
  .fscCheckInput(p)  
  
  opt <- options(scipen = 0)
  p <- .fscWritePar(p) 
  if(p$is.tpl) p <- .fscWriteEst(p)
  options(opt)
  p$formatted.settings <- NULL
  
  invisible(p)
}


#' @noRd
#' 
.fscCheckInput <- function(p) {
  ps <- p$settings
  
  # Check deme info
  if(!inherits(ps$demes, "fscSettingsDemes")) {
    stop("`demes` must be a numeric matrix generated by the `fscSettingsDemes()` function.")
  }
  
  # Check migration rate matrices
  if(!is.null(ps$migration)) {
    if(!inherits(ps$migration, "fscSettingsMigration")) {
      stop("`migration` must be a list of matrices generated by `fscSettingsMigration()`.")
    }
    if(!all(sapply(ps$migration, nrow) == nrow(ps$demes))) {
      stop("All matrices in `migration` must be the same size as the number of demes")
    }
  }
  
  # Check and format historical events
  if(!is.null(ps$events)) {
    if(!inherits(ps$events, "fscSettingsEvents")) {
      stop("`events` must be a numeric matrix generated by `fscSettingsEvents()`.")
    }
    if(any(stats::na.omit(ps$events[, 2:3]) > (nrow(ps$demes) - 1))) {
      stop("There are source or sink populations in `events` not specified in `demes`.")
    }
    max.mig.mat <- max(ps$events[, 7])
    if(max.mig.mat > 0 & (length(ps$migration) < (max.mig.mat + 1))) {
      stop("There are migration matrices in `events` not specified in `migration`.")
    }
  }
  
  # Check genetic info
  if(!inherits(ps$genetics, "fscSettingsGenetics")) {
    stop("`genetics` must be a list of matrices generated by `fscSettingsGenetics()`.")
  }
  if(any(ps$genetics$fsc.type == "FREQ") & attr(ps$demes, "ploidy") != 1) {
    warning("With FREQ type, `ploidy` is set to 1.")
    attr(ps$demes, "ploidy") <- 1
  }
}


#' @noRd
#' 
.fscWritePar <- function(p) {
  p <- .fscFormatSettings(p)
  
  p$files$in.file <- paste0(p$label, ifelse(p$is.tpl, ".tpl", ".par"))
  f <- file(p$files$in.file, open = "wt")
  
  pfs <- p$formatted.settings
  
  n.demes <- nrow(pfs$demes)
  writeLines("//Number of population samples (demes)", f)
  writeLines(as.character(n.demes), f)
  
  writeLines("//Population effective sizes (number of genes)", f)
  for(i in 1:n.demes) writeLines(pfs$demes[i, 1], f)
  
  writeLines("//Sample sizes, times, inbreeding", f)
  for(i in 1:n.demes) writeLines(paste(pfs$demes[i, 2:4], collapse = " "), f)
  
  writeLines("//Growth rates: negative growth implies population expansion", f)
  for(i in 1:n.demes) writeLines(pfs$demes[i, 5], f)
  
  writeLines("//Number of migration matrices: 0 implies no migration between demes", f)
  writeLines(as.character(length(pfs$migration)), f)
  if(!is.null(pfs$migration)) {
    for(i in 1:length(pfs$migration)) {
      writeLines("//migration matrix", f)
      for(r in 1:nrow(pfs$migration[[i]])) {
        writeLines(paste(pfs$migration[[i]][r, ], collapse = " "), f)
      }
    }
  }
  
  writeLines("//Historical events: time, source, sink, migrants, new size, growth rate, migr. matrix", f)
  n.events <- if(is.null(pfs$events)) 0 else nrow(pfs$events)
  writeLines(as.character(n.events), f)
  if(!is.null(pfs$events)) {
    for(r in 1:n.events) writeLines(paste(pfs$events[r, ], collapse = " "), f)
  }
  
  writeLines("//Number of independent loci [chromosomes]", f)
  num.chrom <- attributes(pfs$genetics)["num.chrom"]
  chrom.diff <- as.numeric(attributes(pfs$genetics)["chrom.diff"])
  writeLines(paste(num.chrom, chrom.diff, collapse = " "), f)
  for(block in pfs$genetics) {
    writeLines("//Per chromosome: Number of linkage blocks", f)
    writeLines(as.character(nrow(block)), f)
    writeLines("//Per block: data type, num loci, rec. rate and mut rate + optional parameters", f)
    for(i in 1:nrow(block)) {
      writeLines(paste(as.character(block[i, -1]), collapse = " "), f)
    }
  }
  
  close(f)
  p
}


#' @noRd
#' 
.fscFormatSettings <- function(p) {
  .mat2char <- function(mat) {
    if(is.data.frame(mat)) {
      do.call(cbind, sapply(mat, as.character, simplify = FALSE))
    } else {
      apply(mat, 2, as.character)
    }
    # matrix(
    #   as.character(mat),
    #   nrow = nrow(mat),
    #   dimnames = dimnames(mat)
    # )
  }
  
  .nameParams <- function(mat) {
    # convert NAs to parameters if any exist 
    for(col in colnames(mat)) {
      i <- which(is.na(mat[, col]))
      if(length(i) > 0) mat[i, col] <- toupper(paste0(col, 1:length(i), "$"))
    }
    mat
  }
  
  p$formatted.settings <- list()
  
  # have to increase population size by ploidy as fastsimcoal generates 
  #   haploid number of genes
  ploidy <- attr(p$settings$demes, "ploidy")
  demes <- p$settings$demes
  i <- c("deme.size", "sample.size", "growth")
  demes[, i] <- demes[, i] * ploidy
  p$formatted.settings$demes <- .nameParams(.mat2char(demes))
  
  p$formatted.settings$migration <- if(is.null(p$settings$migration)) {
    NULL
  } else {
    lapply(
      1:length(p$settings$migration), 
      function(m) {
        mat <- .mat2char(p$settings$migration[[m]] / ploidy)
        # convert NAs to parameters 
        for(i in 1:nrow(mat)) {
          for(j in 1:ncol(mat)) {
            if(is.na(mat[i, j])) {
              mat[i, j] <- paste0("MIG", m - 1, "_", i, "_", j, "$", collapse = 0)
            }
          }
        }
        mat
      })
  }
  
  p$formatted.settings$events <- if(is.null(p$settings$events)) {
    NULL
  } else {
    .nameParams(.mat2char(p$settings$events))
  }  
  
  p$formatted.settings$genetics <- p$settings$genetics
  for(chrom in 1:length(p$formatted.settings$genetics)) {
    chr.df <- p$formatted.settings$genetics[[chrom]]
    for(col in colnames(chr.df)) {
      i <- which(is.na(chr.df[, col]))
      if(length(i) > 0) {
        if((col == "num.markers")) stop("Can't estimate number of markers.")
        marker.type <- chr.df[i, "fsc.type"]
        chr.df[i, col] <- ifelse(
          (col == "param.5" & marker.type %in% c("STANDARD", "FREQ")) |
          (col == "param.6" & marker.type %in% c("DNA", "STANDARD", "FREQ")),
          rep("", length(i)),
          toupper(paste0(marker.type , "_", col, "_", 1:length(i), "$"))
        )
      }
    }
    p$formatted.settings$genetics[[chrom]] <- chr.df
  }
  
  # Check for parameters to be estimated
  p$is.tpl <- any(
    c(
      grepl("[$]", p$formatted.settings$demes),
      grepl("[$]", p$formatted.settings$migration),
      grepl("[$]", p$formatted.settings$events),
      grepl("[$]", p$formatted.settings$genetics)
    )
  )

  if(any(p$settings$genetics[[1]]$fsc.type == "FREQ") & !p$is.tpl) {
    stop("Can't use FREQ marker type outside of a parameter estimation model.")
  }
  
  p
}


#' @noRd
#' 
.fscWriteEst <- function(p) {
  p$files$est.file <- paste0(p$label, ".est")
  
  if(file.exists(p$files$est.file) & interactive()) {
    prompt <- paste0(
      "The estimation file, '", p$files$est.file, 
      "' already exists. Overwrite? (Y/n) "
    )
    if(readline(prompt) != "Y") return(p)
  }
  
  f <- file(p$files$est.file, open = "wt")
  
  pfs <- p$formatted.settings
  
  est.df <- data.frame()
  for(col in colnames(pfs$demes)) {
    param <- grep("[$]", pfs$demes[, col], value = T)
    if(length(param) > 0) {
      is.int <- col %in% c("deme.size", "sample.size", "sample.time")
      est.df <- rbind(est.df, data.frame(int = as.numeric(is.int), param))
    }
  }
  
  if(!is.null(pfs$events)) {
    for(col in colnames(pfs$events)) {
      param <- grep("[$]", pfs$events[, col], value = T)
      if(length(param) > 0) {
        is.int <- col %in% c("event.time", "source", "sink", "migr.mat")
        est.df <- rbind(est.df, data.frame(int = as.numeric(is.int), param))
      }
    }
  }
  
  if(!is.null(pfs$migration)) {
    for(mat in pfs$migration) {
      param <- grep("[$]", mat, value = T)
      if(length(param) > 0) est.df <- rbind(est.df, data.frame(int = 0, param))
    }
  }  
  
  for(chrom in pfs$genetics) {
    for(col in colnames(chrom)) {
      param <- grep("[$]", chrom[, col], value = T)
      if(length(param) > 0) {
        is.int <- col == "param.6"
        est.df <- rbind(est.df, data.frame(int = as.numeric(is.int), param))
      }
    }
  }
  
  colnames(est.df) <- c("int", "param")
  est.df$param <- as.character(est.df$param)
  
  writeLines("**** written by strataG::fscWrite() ****", f)
  writeLines("**** edit by hand and delete these 2 lines ****", f)
  writeLines("// Priors and rules file", f)
  writeLines("// *********************", f)
  writeLines("", f)
  writeLines("[PARAMETERS]", f)
  writeLines("//#isInt? #name #dist. #min #max", f)
  writeLines("//all N are in number of haploid individuals", f)
  for(i in 1:nrow(est.df)) {
    writeLines(
      paste0(
        paste(est.df[i, ], collapse = "\t"),
        "\tunif\tmin\tmax\toutput", 
        collapse = ""
      ), 
      f
    )
  }
  writeLines("", f)
  writeLines("[RULES]", f)
  writeLines("", f)
  writeLines("[COMPLEX PARAMETERS]", f)
  for(i in 1:nrow(est.df)) {
    writeLines(
      paste0(paste(est.df[i, ], collapse = "\t"), " = ", collapse = ""), 
      f
    )
  }
  
  close(f)
  
  warning(
    "The estimation file, '", p$files$est.file, 
    "', has been written and must be edited prior to running.",
    call. = FALSE
  )
  
  invisible(p)
}


#' @rdname fscWrite
#' @export
#'
fscWriteSFS <- function(x, label, type = c("maf", "daf")) {
  type <- toupper(match.arg(type))
  if(is.matrix(x) | is.data.frame(x)) {
    f <- paste0(label, "_", type, "pop0.obs")
    write("1 observations", f)
    write(paste0("d0_", names(x), collapse = "\t"), f, append = T)
    write(paste0(x, collapse = "\t"), f, append = T)
    f
  } else {
    avail.demes <- lapply(x, function(mat) names(dimnames(mat))) %>% 
      unlist() %>% 
      unique() %>% 
      sort()
    sapply(x, function(mat) {
      d <- match(names(dimnames(mat)), avail.demes) - 1
      mat <- t(mat)
      rownames(mat) <- paste0("d", d[2], "_", rownames(mat))
      colnames(mat) <- paste0("d", d[1], "_", colnames(mat))
      f <- paste0(
        label, "_joint", type, "pop", d[1], "_", d[2], ".obs",
        collapse = ""
      )
      write("1 observations", f)
      write(paste0(colnames(mat), collapse = "\t"), f, append = T)
      for(i in 1:nrow(mat)) {
        row.i <- paste0(mat[i, ], collapse = "\t")
        write(paste(rownames(mat)[i], row.i, collapse = "\t"), f, append = TRUE)
      }
      f
    })
  }
}