#' @title Read fastsimcoal output
#' @description Read arlequin formatted output or parameter estimation files 
#'   generated by fastsimcoal
#'   
#' @param p list of fastsimcoal input parameters.
#' @param sim number of the simulation replicate to read.
#' @param file filename to read.
#' @param gen.data matrix of parsed genetic data read from .arp file with 
#'   `fscParseGeneticData()`.
#' @param type type of marker to return.
#' @param sep.chrom return a list with chromosomes separated?
#' @param chrom numerical vector giving chromosomes to return. `NULL` 
#'   returns all chromosomes.
#' @param drop.mono drop monomorphic sites before creating `gtypes` object?
#' 
#' @note fastsimcoal is not included with `strataG` and must be downloaded 
#'   separately. Additionally, it must be installed such that it can be run from 
#'   the command line in the current working directory. See the vignette 
#'   for \code{external.programs} for installation instructions.
#' 
#' @references Excoffier, L. and Foll, M (2011) fastsimcoal: a continuous-time 
#'   coalescent simulator of genomic diversity under arbitrarily complex 
#'   evolutionary scenarios Bioinformatics 27: 1332-1334.\cr
#'   Excoffier, L., Dupanloup, I., Huerta-SÃ¡nchez, E., Sousa, V.C., 
#'   and M. Foll (2013) Robust demographic inference from genomic and SNP data. 
#'   PLOS Genetics, 9(10):e1003905. \cr
#'   \url{http://cmpg.unibe.ch/software/fastsimcoal2/}
#' 
#' @author Eric Archer \email{eric.archer@@noaa.gov}
#' 
#' @seealso \code{\link{fastsimcoal.input}}
#' 
#' @name fscRead
#' @export
#' 
fscRead <- function(p, sim = 1) {
  if(p$is.tpl) .fscParseEstParams(p) else .fscParseGeneticData(p, sim)
}


# ---- Estimated Parameters ----

#' @noRd
#' 
.fscParseEstParams <- function(p) {
  .fscReadVector <- function(file) {    
    f <- scan(file, what = "character", sep = "\n", quiet = TRUE)
    stats::setNames(
      as.numeric(do.call(c, strsplit(f[2], "\t"))),
      do.call(c, strsplit(f[1], "\t"))
    )
  }
  
  sfs.file <- dir(
    p$label, 
    pattern = paste0("^", p$label, "_[[:alnum:]]+.txt$"),
    full.names = TRUE
  )  
  brent.file <- dir(
    p$label, 
    pattern = paste0("^", p$label, ".brent_lhoods$"),
    full.names = TRUE
  )
  best.file <- dir(
    p$label, 
    pattern = paste0("^", p$label, ".bestlhoods$"),
    full.names = TRUE
  )
  if(length(sfs.file) == 0 | length(brent.file) == 0 | length(best.file) == 0) {
    stop("Can't file all output files (*.txt, *.brent_lhoods, *.bestlhoods)")
  }
  
  brent.file <- readr::read_lines(brent.file) 
  brent.file <- brent.file[grep("^Param|^[[:digit:]]", brent.file)]
  brent.file <- strsplit(brent.file, "\t")
  brent <- as.data.frame(do.call(rbind, lapply(brent.file[-1], as.numeric)))
  colnames(brent) <- brent.file[[1]][1:ncol(brent)]
  
  sfs.vec <- if(length(sfs.file) == 1) {
    .fscReadVector(sfs.file)
  } else {
    sapply(sfs.file, .fscReadVector, simplify = FALSE)
  }
  
  invisible(
    list(
      ml.params = .fscReadVector(best.file),
      brent.lhoods = brent,
      sfs = sfs.vec
    )
  )
}


# ---- Simulated Data ----

#' @noRd
#' 
.fscParseGeneticData <- function(p, sim = 1) {
  if(!is.numeric(sim) | length(sim) > 1) stop("`sim` must be a single number")
  
  file <- p$files$arp.files[sim]
  cat(format(Sys.time()), "reading", file, "\n")
  arp.data <- fscReadArpFile(file)
  
  # parse data matrix with locus.info mapping
  cat(format(Sys.time()), "parsing locus data...\n")
  gen.data <- if(is.null(arp.data$poly.pos)) {
    .fscParseAllSites(p$locus.info, arp.data$data.mat)
  } else {
    .fscParsePolySites(p$locus.info, arp.data)
  }
  attr(gen.data, "file") <- file
  
  invisible(gen.data)
}


#' @rdname fscRead
#' @export
#' 
fscReadArpFile <- function(file) {
  # read .arp file
  f <- readr::read_lines(file)
  
  # get information on polymorphic sites
  chrom.lines <- grep("polymorphic positions on", f)
  num.poly <- f[chrom.lines]
  num.poly <- as.numeric(regmatches(num.poly, regexpr("[[:digit:]]+", num.poly)))
  
  chrom.poly <- which(num.poly > 0)
  
  poly.pos <- if(length(chrom.poly) > 0) {
    poly.pos <- f[chrom.lines[chrom.poly] + 1]
    poly.pos <- regmatches(poly.pos, gregexpr("[[:digit:]]+", poly.pos))
    do.call(rbind, lapply(1:length(poly.pos), function(i) {
      cbind(chromosome = chrom.poly[i], position = as.numeric(poly.pos[[i]]))
    }))
  } else NULL
  
  # get start and end points of data blocks
  start <- grep("SampleData=", f) + 1
  end <- which(f == "}") - 2
  pos <- cbind(start, end)
  
  data.mat <- if(any((end - start) > 1)) {
    # extract matrix for each data block
    data.mat <- do.call(rbind, lapply(1:nrow(pos), function(i, pos) {
      f.line <- f[pos[i, 1]:pos[i, 2]]
      result <- do.call(rbind, strsplit(f.line, "[[:space:]]+"))[, -2]
      cbind(result[, 1], paste0("Deme.", rep(i, nrow(result))), result[, -1])
    }, pos = pos))
    colnames(data.mat) <- c("id", "deme", paste0("col", 3:ncol(data.mat)))
    data.mat
  } else  NULL
  
  list(poly.pos = poly.pos, data.mat = data.mat)
}


#' @noRd
#' 
.fscParseAllSites <- compiler::cmpfun(function(locus.info, data.mat) {
  # for each row in locus.info, create matrix of loci in that block
  # return list of block matrices
  gen.data <- vector("list", nrow(locus.info))
  for(i in 1:nrow(locus.info)) {
    cols <- data.mat[, locus.info$mat.col.start[i]:locus.info$mat.col.end[i]]
    # extract DNA sequence from string in column
    if(locus.info$fsc.type[i] == "DNA") {
      start <- locus.info$dna.start[i]
      end <- locus.info$dna.end[i]
      if(any(is.na(c(start, end)))) {
        start <- 1
        end <- nchar(cols[1])
      }
      cols <- stringi::stri_sub(cols, start, end)
      if(locus.info$actual.type[i] == "SNP") {
        cols <- do.call(rbind, strsplit(cols, ""))
      }
    }
    cols <- cbind(cols)
    # give suffixes to block names with more than one locus
    colnames(cols) <- if(ncol(cols) == 1) {
      locus.info$name[i] 
    } else {
      paste0(locus.info$name[i], "_L", .zeroPad(1:ncol(cols)))
    }
    gen.data[[i]] <- cols
  }
  
  # create map of column numbers in gen.data for each row of locus.info
  last.col <- 2
  locus.cols <- vector("list", nrow(locus.info))
  names(locus.cols) <- locus.info$name
  for(i in 1:length(gen.data)) {
    locus.cols[[i]] <- (last.col + 1):(last.col + ncol(gen.data[[i]]))
    last.col <- max(locus.cols[[i]])
  }
  
  gen.data <- do.call(cbind, gen.data)
  gen.data <- cbind(data.mat[, 1:2], gen.data)  
  attr(gen.data, "locus.cols") <- locus.cols
  gen.data
})


#' @noRd
#' 
.fscParsePolySites <- function(locus.info, arp.data) {
  poly.pos <- arp.data$poly.pos
  
  loc.info.row <- apply(poly.pos, 1, function(x) {
    chr.rows <- which(locus.info$chromosome == x["chromosome"])
    i <- findInterval(
      x["position"], 
      locus.info[chr.rows, "chrom.pos.start"]
    )
    chr.rows[i]
  })
  
  poly.pos <- cbind(poly.pos, loc.info.row = loc.info.row) %>% 
    as.data.frame() %>% 
    dplyr::mutate(
      name = locus.info[.data$loc.info.row, "name"],
      actual.type = locus.info[.data$loc.info.row, "actual.type"],
      fsc.type = locus.info[.data$loc.info.row, "fsc.type"]
    ) 
  
  prev.type <- lag(poly.pos$fsc.type)
  new.col <- as.numeric(!(poly.pos$fsc.type == "DNA" & prev.type == "DNA"))
  new.col[1] <- 1
  poly.pos$mat.col <- cumsum(new.col) + 2
  
  poly.pos <- poly.pos %>% 
    dplyr::group_by(.data$mat.col) %>% 
    dplyr::mutate(dna.pos = ifelse(.data$fsc.type == "DNA", 1:dplyr::n(), NA)) %>% 
    dplyr::ungroup() %>% 
    as.data.frame()
  
  poly.pos <- split(poly.pos, poly.pos$name)
  gen.data <- vector("list", length(poly.pos))
  for(i in 1:length(poly.pos)) {
    name.df <- poly.pos[[i]]
    cols <- arp.data$data.mat[, sort(unique(name.df$mat.col))]
    marker.type <- unique(name.df$actual.type)
    if(marker.type %in% c("DNA", "SNP")) {
      n <- nrow(name.df)
      cols <- stringi::stri_sub(cols, name.df$dna.pos[1], name.df$dna.pos[n])
      if(marker.type == "SNP") cols <- do.call(rbind, strsplit(cols, ""))
    }
    cols <- cbind(cols)
    # give suffixes to block names with more than one locus
    colnames(cols) <- if(ncol(cols) == 1) {
      name.df$name[1]
    } else {
      paste0(name.df$name[1], "_L", .zeroPad(1:ncol(cols)))
    }
    gen.data[[i]] <- cols
  }
  
  # create map of column numbers in gen.data for each row of locus.info
  last.col <- 2
  locus.cols <- vector("list", length(poly.pos))
  names(locus.cols) <- names(poly.pos)
  for(i in 1:length(gen.data)) {
    locus.cols[[i]] <- (last.col + 1):(last.col + ncol(gen.data[[i]]))
    last.col <- max(locus.cols[[i]])
  }
  
  gen.data <- do.call(cbind, gen.data)
  gen.data <- cbind(arp.data$data.mat[, 1:2], gen.data)  
  attr(gen.data, "locus.cols") <- locus.cols
  attr(gen.data, "poly.pos") <- do.call(rbind, poly.pos)
  gen.data
}


#' @rdname fscRead
#' @export
#' 
fscExtractLoci <- function(p, sim = 1, gen.data = NULL, type = "all", 
                           sep.chrom = FALSE, chrom = NULL) {
  if(is.null(gen.data)) {
    if(p$is.tpl) {
      stop("Can't extract loci because 'p' specifies a parameter estimation model.")
    }
    gen.data <- fscRead(p, sim)
  } 
  file <- attr(gen.data, "file")
  
  # filter locus info for specified chromosomes
  locus.info <- p$locus.info
  if(!is.null(chrom)) {
    if(!is.numeric(chrom)) stop("'chrom' must be a numeric vector")
    if(max(chrom) > max(locus.info$chromosome)) {
      stop("there are not", max(chrom), "chromosomes available") 
    }
    locus.info <- locus.info[locus.info$chromosome %in% chrom, ]
  }
  
  # check marker type
  type <- toupper(type)
  if(!all(type %in% c("DNA", "SNP", "MICROSAT", "STANDARD", "ALL"))) {
    stop("`type` can only contain 'dna', 'snp', 'microsat', 'standard', 'all'.")
  }
  if("ALL" %in% type) type <- unique(locus.info$actual.type)
  
  # filter locus info for specified marker types
  locus.info <- locus.info[grep(paste(type, collapse = "|"), locus.info$name), ]
  
  .extractLocCols <- function(loc.names, mat) {
    loc.cols <- unlist(attr(mat, "locus.cols")[loc.names]) 
    mat[, c(1:2, loc.cols), drop = FALSE]
  }
  
  # extract columns for selected chromosomes and marker types
  gen.data <- if(sep.chrom) { # extract for each chromosome
    locus.info$chrom.label <- regmatches(
      locus.info$name,
      regexpr("^C[[:alnum:]]+", locus.info$name)
    )
    tapply( 
      locus.info$name, 
      locus.info$chrom.label,
      .extractLocCols,
      mat = gen.data
    )
  } else { # extract selected loci from data frame
    .extractLocCols(locus.info$name, gen.data)
  }
  
  attr(gen.data, "file") <- file
  gen.data
}
