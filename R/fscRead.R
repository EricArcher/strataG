#' @title Read fastsimcoal output
#' @description Read arlequin formatted output or parameter estimation files 
#'   generated by fastsimcoal
#'   
#' @param p list of fastsimcoal input parameters.
#' @param sim number of the simulation replicate to read.
#' @param file filename to read.
#' @param marker type of marker to return.
#' @param chrom numerical vector giving chromosomes to return. `NULL` 
#'   returns all chromosomes.
#' @param sep.chrom return a list with chromosomes separated?
#' @param drop.mono return only polymorphic loci?
#' @param as.genotypes return data as genotypes? If `FALSE`, original haploid 
#'   data is returned. If `TRUE`, individuals are created by combining 
#'   sequential haplotypes based on the ploidy used to run the simulation 
#' @param one.col return genotypes with one column per locus? If `FALSE`, 
#'   alleles are split into separate columns and designated as ".1", ".2", etc. 
#'   for each locus
#' @param sep character to use to separate alleles if `one.col = TRUE`.
#' @param coded.snps return diploid SNPs coded as 0 (major allele homozygote), 
#'   1 (heterozygote), or 2 (minor allele homozygote). If this is `TRUE` and 
#'   `marker = "snp"` and the data is diploid, genotypes will be returned with 
#'   one column per locus.
#' @param label character string giving the folder with simulation output.
#' 
#' @note fastsimcoal is not included with `strataG` and must be downloaded 
#'   separately. Additionally, it must be installed such that it can be run from 
#'   the command line in the current working directory. See the vignette 
#'   for \code{external.programs} for installation instructions.
#' 
#' @references Excoffier, L. and Foll, M (2011) fastsimcoal: a continuous-time 
#'   coalescent simulator of genomic diversity under arbitrarily complex 
#'   evolutionary scenarios Bioinformatics 27: 1332-1334.\cr
#'   Excoffier, L., Dupanloup, I., Huerta-SÃ¡nchez, E., Sousa, V.C., 
#'   and M. Foll (2013) Robust demographic inference from genomic and SNP data. 
#'   PLOS Genetics, 9(10):e1003905. \cr
#'   \url{http://cmpg.unibe.ch/software/fastsimcoal2/}
#' 
#' @author Eric Archer \email{eric.archer@@noaa.gov}
#' 
#' @seealso \code{\link{fsc.input}}
#' 
#' @name fscRead
#' @export
#' 
fscRead <- function(p, sim = 1,
                    marker = c("all", "snp", "microsat", "dna", "standard"),
                    chrom = NULL, sep.chrom = FALSE, drop.mono = TRUE, 
                    as.genotypes = TRUE, one.col = TRUE, sep = "/", 
                    coded.snps = FALSE) {
  if(p$is.tpl) {
    fscReadEstParams(p$label) 
  } else {
    hap.data <- .fscParseGeneticData(p, sim)
    if(is.null(hap.data)) return(NULL)
    file <- attr(hap.data, "file")
    hap.data <- .fscSelectLoci(
      hap.data, p$locus.info, marker, chrom, sep.chrom, drop.mono
    )
    ploidy <- attr(p$settings$demes, "ploidy")
    data.mat <- if(as.genotypes & ploidy > 1) {
      .fscFormatGenotypes(hap.data, ploidy, one.col, sep, coded.snps)
    } else as.data.frame(hap.data, stringsAsFactors = FALSE)
    attr(data.mat, "poly.pos") <- attr(hap.data, "poly.pos")
    attr(data.mat, "file") <- file
    data.mat
  }
}


# ---- Estimated Parameters ----

#' @rdname fscRead
#' @export
#' 
fscReadEstParams <- function(label) {
  .fscReadVector <- function(file) {    
    f <- scan(file, what = "character", sep = "\n", quiet = TRUE)
    stats::setNames(
      as.numeric(do.call(c, strsplit(f[2], "\t"))),
      do.call(c, strsplit(f[1], "\t"))
    )
  }
  
  sfs.file <- dir(
    label, 
    pattern = paste0("^", label, "_[[:alnum:]]+.txt$"),
    full.names = TRUE
  )  
  brent.file <- dir(
    label, 
    pattern = paste0("^", label, ".brent_lhoods$"),
    full.names = TRUE
  )
  best.file <- dir(
    label, 
    pattern = paste0("^", label, ".bestlhoods$"),
    full.names = TRUE
  )
  if(length(sfs.file) == 0 | length(brent.file) == 0 | length(best.file) == 0) {
    stop("Can't find all output files (*.txt, *.brent_lhoods, *.bestlhoods)")
  }
  
  brent.file <- readr::read_lines(brent.file) 
  brent.file <- brent.file[grep("^Param|^[[:digit:]]", brent.file)]
  brent.file <- strsplit(brent.file, "\t")
  brent <- as.data.frame(do.call(rbind, lapply(brent.file[-1], as.numeric)))
  colnames(brent) <- brent.file[[1]][1:ncol(brent)]
  
  sfs.vec <- if(length(sfs.file) == 1) {
    .fscReadVector(sfs.file)
  } else {
    sapply(sfs.file, .fscReadVector, simplify = FALSE)
  }
  
  invisible(
    list(
      ml.params = .fscReadVector(best.file),
      brent.lhoods = brent,
      sfs = sfs.vec
    )
  )
}


# ---- Simulated Data ----

#' @noRd
#' 
.fscParseGeneticData <- function(p, sim = 1) {
  if(!is.numeric(sim) | length(sim) > 1) stop("`sim` must be a single number")
  
  file <- p$files$arp.files[sim]
  cat(format(Sys.time()), "reading", file, "\n")
  data.mat <- fscReadArpFile(file)
  if(is.null(data.mat)) return(NULL)
  
  # parse data matrix with locus.info mapping
  cat(format(Sys.time()), "parsing genetic data...\n")
  gen.data <- if(is.null(attr(data.mat, "poly.pos"))) {
    .fscParseAllSites(p$locus.info, data.mat)
  } else {
    .fscParsePolySites(p$locus.info, data.mat)
  }
  attr(gen.data, "file") <- file
  
  invisible(gen.data)
}


#' @rdname fscRead
#' @export
#' 
fscReadArpFile <- function(file) {
  # read .arp file
  f <- readr::read_lines(file)
  
  # get information on polymorphic sites
  chrom.lines <- grep("polymorphic positions on", f)
  poly.pos <- if(length(chrom.lines) != 0) {
    num.poly <- f[chrom.lines]
    num.poly <- regmatches(num.poly, regexpr("[[:digit:]]+", num.poly))
    chrom.poly <- which(as.numeric(num.poly) > 0)
    if(length(chrom.poly) > 0) {
      poly.pos <- f[chrom.lines[chrom.poly] + 1]
      poly.pos <- regmatches(poly.pos, gregexpr("[[:digit:]]+", poly.pos))
      do.call(rbind, lapply(1:length(poly.pos), function(i) {
        cbind(chromosome = chrom.poly[i], position = as.numeric(poly.pos[[i]]))
      }))
    } else {
      warning("No polymorphic sites found. NULL returned.", call. = FALSE)
      return(NULL)
    }
  } else NULL
  
  # get start and end points of data blocks
  start <- grep("SampleData=", f) + 1
  end <- which(f == "}") - 2
  pos <- cbind(start, end)
  
  data.mat <- if(any((end - start) > 1)) {
    # extract matrix for each data block
    data.mat <- do.call(rbind, lapply(1:nrow(pos), function(i, pos) {
      f.line <- f[pos[i, 1]:pos[i, 2]]
      result <- do.call(rbind, strsplit(f.line, "[[:space:]]+"))[, -2]
      cbind(result[, 1], paste0("Deme.", rep(i, nrow(result))), result[, -1])
    }, pos = pos))
    colnames(data.mat) <- c("id", "deme", paste0("col", 3:ncol(data.mat)))
    data.mat
  } else  NULL
  
  attr(data.mat, "poly.pos") <- poly.pos
  data.mat
}


#' @noRd
#' 
.fscParseAllSites <- compiler::cmpfun(function(locus.info, data.mat) {
  # for each row in locus.info, create matrix of loci in that block
  # return list of block matrices
  gen.data <- vector("list", nrow(locus.info))
  for(i in 1:nrow(locus.info)) {
    cols <- data.mat[, locus.info$mat.col.start[i]:locus.info$mat.col.end[i]]
    # extract DNA sequence from string in column
    if(locus.info$fsc.type[i] == "DNA") {
      start <- locus.info$dna.start[i]
      end <- locus.info$dna.end[i]
      if(any(is.na(c(start, end)))) {
        start <- 1
        end <- nchar(cols[1])
      }
      cols <- stringi::stri_sub(cols, start, end)
      if(locus.info$actual.type[i] == "SNP") {
        cols <- do.call(rbind, strsplit(cols, ""))
      }
    }
    cols <- cbind(cols)
    # give suffixes to block names with more than one locus
    colnames(cols) <- if(ncol(cols) == 1) {
      locus.info$name[i] 
    } else {
      paste0(locus.info$name[i], "_L", .zeroPad(1:ncol(cols)))
    }
    gen.data[[i]] <- cols
  }
  
  # create map of column numbers in gen.data for each row of locus.info
  last.col <- 2
  locus.cols <- vector("list", nrow(locus.info))
  names(locus.cols) <- locus.info$name
  for(i in 1:length(gen.data)) {
    locus.cols[[i]] <- (last.col + 1):(last.col + ncol(gen.data[[i]]))
    last.col <- max(locus.cols[[i]])
  }
  
  gen.data <- do.call(cbind, gen.data)
  gen.data <- cbind(data.mat[, 1:2], gen.data)  
  attr(gen.data, "locus.cols") <- locus.cols
  gen.data
})


#' @noRd
#' 
.fscParsePolySites <- function(locus.info, data.mat) {
  poly.pos <- attr(data.mat, "poly.pos")
  
  loc.info.row <- apply(poly.pos, 1, function(x) {
    chr.rows <- which(locus.info$chromosome == x["chromosome"])
    i <- findInterval(
      x["position"], 
      locus.info[chr.rows, "chrom.pos.start"]
    )
    chr.rows[i]
  })
  
  poly.pos <- cbind(poly.pos, loc.info.row = loc.info.row) %>% 
    as.data.frame() %>% 
    dplyr::mutate(
      name = locus.info[.data$loc.info.row, "name"],
      actual.type = locus.info[.data$loc.info.row, "actual.type"],
      fsc.type = locus.info[.data$loc.info.row, "fsc.type"]
    ) 
  
  prev.type <- dplyr::lag(poly.pos$fsc.type)
  same.col <- as.numeric(!(poly.pos$fsc.type == "DNA" & prev.type == "DNA"))
  same.col[1] <- 1
  poly.pos$mat.col <- cumsum(same.col) + 2
  
  poly.pos <- poly.pos %>% 
    dplyr::group_by(.data$mat.col) %>% 
    dplyr::mutate(dna.pos = ifelse(.data$fsc.type == "DNA", 1:dplyr::n(), NA)) %>% 
    dplyr::ungroup() %>% 
    as.data.frame()
  
  poly.pos <- split(poly.pos, poly.pos$name)
  gen.data <- vector("list", length(poly.pos))
  for(i in 1:length(poly.pos)) {
    name.df <- poly.pos[[i]]
    cols <- data.mat[, sort(unique(name.df$mat.col))]
    marker.type <- unique(name.df$actual.type)
    if(marker.type %in% c("DNA", "SNP")) {
      n <- nrow(name.df)
      cols <- stringi::stri_sub(cols, name.df$dna.pos[1], name.df$dna.pos[n])
      if(marker.type == "SNP") cols <- do.call(rbind, strsplit(cols, ""))
    }
    cols <- cbind(cols)
    # give suffixes to block names with more than one locus
    colnames(cols) <- if(ncol(cols) == 1) {
      name.df$name[1]
    } else {
      paste0(name.df$name[1], "_L", .zeroPad(1:ncol(cols)))
    }
    gen.data[[i]] <- cols
  }
  
  # create map of column numbers in gen.data for each row of locus.info
  last.col <- 2
  locus.cols <- vector("list", length(poly.pos))
  names(locus.cols) <- names(poly.pos)
  for(i in 1:length(gen.data)) {
    locus.cols[[i]] <- (last.col + 1):(last.col + ncol(gen.data[[i]]))
    last.col <- max(locus.cols[[i]])
  }
  
  gen.data <- do.call(cbind, gen.data)
  gen.data <- cbind(data.mat[, 1:2], gen.data)  
  attr(gen.data, "locus.cols") <- locus.cols
  attr(gen.data, "poly.pos") <- do.call(rbind, poly.pos)
  rownames(attr(gen.data, "poly.pos")) <- NULL
  gen.data
}


#' @noRd
#' 
.fscSelectLoci <- function(hap.data, locus.info, marker, chrom, sep.chrom, 
                           drop.mono) {
  poly.pos <- attr(hap.data, "poly.pos")
  
  # filter locus info for specified chromosomes
  if(!is.null(chrom)) {
    if(!is.numeric(chrom)) stop("'chrom' must be a numeric vector")
    if(max(chrom) > max(locus.info$chromosome)) {
      stop("there are not", max(chrom), "chromosomes available") 
    }
    locus.info <- locus.info[locus.info$chromosome %in% chrom, ]
  }
  
  # check that requested marker type is available
  marker <- toupper(marker)
  if(!all(marker %in% c("DNA", "SNP", "MICROSAT", "STANDARD", "ALL"))) {
    stop("`marker` can only contain 'dna', 'snp', 'microsat', 'standard', 'all'.")
  }
  if("ALL" %in% marker) marker <- unique(locus.info$actual.type)
  
  # filter locus info for requested marker types
  i <- grep(paste(marker, collapse = "|"), locus.info$name)
  if(length(i) == 0) {
    stop("No loci available for selected marker types on selected chromosomes.")
  }
  locus.info <- locus.info[i, , drop = FALSE]
  
  # extract columns for selected chromosomes and marker types
  .extractLocCols <- function(loc.names, mat) {
    loc.cols <- unlist(attr(mat, "locus.cols")[loc.names]) 
    mat[, c(1:2, loc.cols), drop = FALSE]
  }
  hap.data <- if(sep.chrom) { # extract for each chromosome and return list
    locus.info$chrom.label <- regmatches(
      locus.info$name,
      regexpr("^C[[:alnum:]]+", locus.info$name)
    )
    tapply( 
      locus.info$name, 
      locus.info$chrom.label,
      .extractLocCols,
      mat = hap.data
    )
  } else { # extract selected loci from data frame
    .extractLocCols(locus.info$name, hap.data)
  }
  
  if(!is.null(poly.pos)) {
    poly.pos <- poly.pos[poly.pos$name %in% colnames(hap.data), , drop = FALSE]
    attr(hap.data, "poly.pos") <- poly.pos
  }
  hap.data
}


#' @noRd
#' 
.fscFormatGenotypes <- function(hap.data, ploidy, one.col, sep, coded.snps) {  
  if(coded.snps) { # check that coded SNPs can be returned
    num.snp.cols <- grepl("_SNP", colnames(hap.data)) # all loci must be SNPs
    if(!sum(num.snp.cols) == ncol(hap.data) - 2) {
      stop("Select `marker = \"snp\"` to return coded SNPs.")
    }
    if(ploidy != 2) stop("Can't code SNPs in non-diploid data.")
  }
  
  # vector of numeric ids to group alleles for individuals
  gen.id <- rep(1:(nrow(hap.data) / ploidy), each = ploidy)
  
  if(one.col | coded.snps) {
    # matrix of id and deme for each individual
    id.mat <- do.call(rbind, tapply(1:nrow(hap.data), gen.id, function(i) {
      c(
        id = paste(hap.data[i, "id"], collapse = sep), 
        deme = hap.data[i, "deme"][1]
      )
    })) %>% 
      as.data.frame(stringsAsFactors = FALSE)
    # matrix of genotypes with one column per locus
    gen.mat <- apply(hap.data[, -(1:2), drop = FALSE], 2, function(loc) {
      if(coded.snps) {
        minor.allele <- names(which.min(table(loc)))
        tapply(loc, gen.id, function(x) sum(x == minor.allele))
      } else {
        tapply(loc, gen.id, paste, collapse = sep)
      }
    })
    cbind(id.mat, gen.mat, stringsAsFactors = FALSE)
  } else {
    # matrix of ids, demes, and genotypes with ploidy columns per locus
    gen.mat <- do.call(rbind, tapply(1:nrow(hap.data), gen.id, function(i) {
      id <- paste(hap.data[i, "id"], collapse = sep)
      c(id = id, deme = hap.data[i, "deme"][1], as.vector(hap.data[i, -(1:2)]))
    }))
    colnames(gen.mat)[-(1:2)] <- paste(
      rep(colnames(hap.data)[-(1:2)], each = ploidy), 
      1:ploidy, 
      sep = "."
    )
    as.data.frame(gen.mat, stringsAsFactors = FALSE)
  }
}